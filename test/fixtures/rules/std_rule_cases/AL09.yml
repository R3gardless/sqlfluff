rule: AL09

test_pass_no_self_alias:
    # Test that the rule passes when there's no self alias.
    pass_str: |
        select
            no_alias,
            col_b as rename_alias,
            max(sum) as max_sum
        from foo

test_fail_no_quotes_same_case:
    # When unquoted and the same case, we should always remove the alias.
    fail_str: |
        select
            col_a as this_alias_is_fine,
            col_b as col_b,
            COL_C as COL_C,
            Col_D as Col_D,
            col_e col_e,
            COL_F COL_F,
            Col_G Col_G
        from foo
    fix_str: |
        select
            col_a as this_alias_is_fine,
            col_b,
            COL_C,
            Col_D,
            col_e,
            COL_F,
            Col_G
        from foo

test_fail_no_quotes_different_case:
    # When unquoted and the a different case we remove the alias *but* we keep
    # the version of the name which the *alias* uses, not the version used by
    # the *reference*. This is because in some dialects (Biquery and TSQL) while
    # unquoted references are case insensitive when looking up objects, they
    # do make a difference in the capitalisation of columns in the result.
    # We're aiming here to choose the safer route and keep that case sensitive
    # alias and not the case insensitive reference.
    # While this can make the capitalisation look inconsistent, that's a job
    # for the capitalisation rules and not this one.
    fail_str: |
        select
            col_a as this_alias_is_fine,
            col_b as Col_B,
            COL_C as col_c,
            Col_D as COL_D,
            col_e Col_e,
            COL_F col_f,
            Col_G COL_G
        from foo
    fix_str: |
        select
            col_a as this_alias_is_fine,
            Col_B,
            col_c,
            COL_D,
            Col_E,
            col_f,
            COL_G
        from foo

test_fail_both_quotes_same_case:
    # When *both* quoted and the same case, we should always remove the alias.
    fail_str: |
        select
            "col_a" as "this_alias_is_fine",
            "col_b" as "col_b",
            "COL_C" as "COL_C",
            "Col_D" as "Col_D",
            "col_e" "col_e",
            "COL_F" "COL_F",
            "Col_G" "Col_G"
        from foo
    fix_str: |
        select
            "col_a" as "this_alias_is_fine",
            "col_b",
            "COL_C",
            "Col_D",
            "col_e",
            "COL_F",
            "Col_G"
        from foo

test_pass_both_quotes_different_case:
    # When *both* quoted and the different cases, then it's always ok.
    pass_str: |
        select
            "col_a" as "this_alias_is_fine",
            "col_b" as "Col_B",
            "COL_C" as "col_c",
            "Col_D" as "COL_D",
            "col_e" "Col_E",
            "Col_F" "COL_F",
            "col_g" "Col_G"
        from foo

test_fail_with_table_aliasing:
    # Test the fixes above when the table is also aliased and columns qualified.
    fail_str: |
        select
            bar.col_a as this_alias_is_fine,
            bar.col_b as col_b,
            bar.COL_C as Col_C,
            bar."Col_D" as "Col_D",
            bar.col_e col_e,
            bar.COL_F Col_F,
            bar."Col_G" "Col_G"
        from foo as bar
    fix_str: |
        select
            bar.col_a as this_alias_is_fine,
            bar.col_b,
            bar.Col_C,
            bar."Col_D",
            bar.col_e,
            bar.Col_F,
            bar."Col_G"
        from foo as bar

test_pass_table_aliasing:
    # This rule doesn't handle table self-aliasing, that should be a different rule.
    pass_str: |
        select *
        from foo as foo
        inner join BAR as BAR using(some_key)
        inner join Boo as Boo using(some_key)
        inner join "abc" as "abc" using(some_key)
        inner join "BCA" as "BCA" using(some_key)
        inner join "Cab" as "Cab" using(some_key)
        inner join def def using(some_key)
        inner join FDE FDE using(some_key)
        inner join Efd Efd using(some_key)

test_pass_self_alias_case_sensitive:
    # Renaming the column name from case-insensitive to case-sensitive
    pass_str:
        select
            col_a as "col_a",
            col_b as new_col_b
        from foo

test_pass_mysql_quoted_identifiers:
    pass_str: |
        SELECT
            users.email AS "Email_in_double_quotes",
            users.email AS "Email""with_escaped_double_quotes",
            users.email AS `Email_in_backticks`,
            users.email AS 'Email_in_single_quotes'
        FROM users;
    configs:
        core:
            dialect: mysql

test_fail_quoted_reference_only_uppercase:
    # This test covers the behaviour when the reference is quoted but the alias isn't
    # and the case of the two is different.
    # Specifically for this test case, when the dialect casefolds identifiers to UPPERCASE.
    # e.g. Snowflake
    # NOTE: In the cases where we *do* fix, for consistency with dialect which respect the
    # casing of the *alias* in result sets, we retain the quoting and formatting of the
    # *alias* rather than the *reference*.
    fail_str: |
        select
            "foo" as FOO,
            "FOO" as Foo,
            "Foo" as foo,
            "foo" FOO,
            "FOO" Foo,
            "Foo" foo
        from foo
    fix_str: |
        select
            "foo" as FOO,
            Foo,
            "Foo" as foo,
            "foo" FOO,
            Foo,
            "Foo" foo
        from foo
    configs:
        core:
            dialect: snowflake

test_fail_quoted_reference_only_lowercase:
    # This test covers the behaviour when the reference is quoted but the alias isn't
    # and the case of the two is different.
    # Specifically for this test case, when the dialect casefolds identifiers to lowercase.
    # e.g. MySQL
    # NOTE: In the cases where we *do* fix, for consistency with dialect which respect the
    # casing of the *alias* in result sets, we retain the quoting and formatting of the
    # *alias* rather than the *reference*.
    fail_str: |
        select
            `foo` as FOO,
            `FOO` as Foo,
            `Foo` as foo,
            `foo` FOO,
            `FOO` Foo,
            `Foo` foo
        from foo
    fix_str: |
        select
            FOO,
            `FOO` as Foo,
            `Foo` as foo,
            FOO,
            `FOO` Foo,
            `Foo` foo
        from foo
    configs:
        core:
            dialect: mysql

test_fail_quoted_alias_only_uppercase:
    # This test covers the behaviour when the alias is quoted but the reference isn't
    # and the case of the two is different.
    # Specifically for this test case, when the dialect casefolds identifiers to UPPERCASE.
    # e.g. Snowflake
    # NOTE: In the cases where we *do* fix, for consistency with dialect which respect the
    # casing of the *alias* in result sets, we retain the quoting and formatting of the
    # *alias* rather than the *reference*.
    fail_str: |
        select
            foo as "FOO",
            FOO as "Foo",
            Foo as "foo",
            foo "FOO",
            FOO "Foo",
            Foo "foo"
        from foo
    fix_str: |
        select
            "FOO",
            FOO as "Foo",
            Foo as "foo",
            "FOO",
            FOO "Foo",
            Foo "foo"
        from foo
    configs:
        core:
            dialect: snowflake

test_fail_quoted_alias_only_lowercase:
    # This test covers the behaviour when the alias is quoted but the reference isn't
    # and the case of the two is different.
    # Specifically for this test case, when the dialect casefolds identifiers to lowercase.
    # e.g. DuckDB
    # NOTE: In the cases where we *do* fix, for consistency with dialect which respect the
    # casing of the *alias* in result sets, we retain the quoting and formatting of the
    # *alias* rather than the *reference*.
    fail_str: |
        select
            foo as `FOO`,
            FOO as `Foo`,
            Foo as `foo`,
            foo `FOO`,
            FOO `Foo`,
            Foo `foo`
        from foo
    fix_str: |
        select
            FOO as `FOO`,
            FOO as `Foo`,
            `foo`,
            FOO `FOO`,
            FOO `Foo`,
            `foo`
        from foo
    configs:
        core:
            dialect: duckdb
