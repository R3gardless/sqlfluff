rule: AL09

test_pass_no_self_alias:
    # Test that the rule passes when there's no self alias.
    pass_str: |
        select
            no_alias,
            col_b as rename_alias,
            max(sum) as max_sum
        from foo

test_fail_no_quotes_same_case:
    # When unquoted and the same case, we should always remove the alias.
    fail_str: |
        select
            col_a as this_alias_is_fine,
            col_b as col_b,
            COL_C as COL_C,
            Col_D as Col_D,
            col_e col_e,
            COL_F COL_F,
            Col_G Col_G
        from foo
    fix_str: |
        select
            col_a as this_alias_is_fine,
            col_b,
            COL_C,
            Col_D,
            col_e,
            COL_F,
            Col_G
        from foo

test_fail_with_quotes_same_case:
    # When quoted and the same case, we should always remove the alias.
    fail_str: |
        select
            "col_a" as "this_alias_is_fine",
            "col_b" as "col_b",
            "COL_C" as "COL_C",
            "Col_D" as "Col_D",
            "col_e" "col_e",
            "COL_F" "COL_F",
            "Col_G" "Col_G"
        from foo
    fix_str: |
        select
            "col_a" as "this_alias_is_fine",
            "col_b",
            "COL_C",
            "Col_D",
            "col_e",
            "COL_F",
            "Col_G"
        from foo

test_pass_different_case:
    # If the casing is different, even if the quoting is the same, we
    # should never fail/fix the rule. If CP02 changes the casing we
    # might trigger after that, but by then the casing will be different.
    pass_str: |
        select
            col_a as this_alias_is_fine,
            col_b as Col_B,
            COL_C as col_c,
            Col_D as COL_D,
            col_e Col_e,
            COL_F col_f,
            Col_G COL_G,
            "col_b" as "Col_B",
            "COL_C" as "col_c",
            "Col_D" as "COL_D",
            "col_e" "Col_e",
            "COL_F" "col_f",
            "Col_G" "COL_G"
        from foo

test_pass_different_quotes:
    # If the quoting is different, even if the casing is the same, we
    # should never fail/fix the rule. If RF06 changes the quoting we
    # might trigger after that, but by then the quoting will be different.
    pass_str: |
        select
            col_a as this_alias_is_fine,
            "col_b" as col_b,
            COL_C as "COL_C",
            "Col_D" as Col_D,
            col_e "col_e",
            "COL_F" COL_F,
            Col_G "Col_G"
        from foo

test_pass_mysql_quoted_identifiers:
    pass_str: |
        SELECT
            users.email AS "Email_in_double_quotes",
            users.email AS "Email""with_escaped_double_quotes",
            users.email AS `Email_in_backticks`,
            users.email AS 'Email_in_single_quotes'
        FROM users;
    configs:
        core:
            dialect: mysql
